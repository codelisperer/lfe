.\" Automatically generated by Pandoc 2.19.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "lfe_io" "3" "2008-2019" "" ""
.hy
.SH NAME
.PP
lfe_io - Lisp Flavoured Erlang (LFE) io functions
.SH SYNOPSIS
.PP
This module provides a standard set of io functions for LFE.
In the following description, many functions have an optional parameter
IoDevice.
If included, it must be the pid of a process which handles the IO
protocols such as the IoDevice returned by file:open/2.
.PP
Two functions in this module are used to generate aesthetically
attractive representations of abstract forms, which are suitable for
printing.
These functions return (possibly deep) lists of characters and generate
an error if the form is wrong.
.SH DATA TYPES
.PP
\f[B]chars() = [char() | chars()]\f[R]
.PP
\f[B]filesexpr() = {Sexpr,Line}\f[R]
.PP
This is the format returned by \f[V]lfe_io:parse_file/1\f[R] and is used
by the compiler to give better error information.
.SH EXPORTS
.PP
\f[B]get_line([[IoDevice,] Prompt]) -> Data | {error,ErrorInfo} |
eof\f[R]
.PP
Reads a line from the standard input (\f[V]IoDevice\f[R]), prompting it
with prompt (\f[V]Prompt\f[R]).
Note that this call guarantees that the input is saved in the input
hisotry.
.PP
\f[B]read([[IoDevice,] Prompt]) -> {ok,Sexpr} | {error,ErrorInfo} |
eof\f[R]
.PP
Read an s-expr from the standard input (\f[V]IoDevice\f[R]) with a
prompt (\f[V]Prompt\f[R]).
Note that this is not line-oriented in that it stops as soon as it has
consumed enough characters.
.PP
\f[B]read_line([[IoDevice,] Prompt]) -> {ok,Sexpr} | {error,ErrorInfo} |
eof\f[R]
.PP
Read an s-expr from the standard input (\f[V]IoDevice\f[R]) with a
prompt (\f[V]Prompt\f[R]).
Note that this is line-oriented in that it reads whole lines discarding
left-over characters in the last line.
.PP
\f[B]read_string(String) -> {ok,Sexpr} | {error,ErrorInfo}\f[R]
.PP
Read an s-expr from \f[V]String\f[R].
Note that this only reads from \f[V]String\f[R] discarding left-over
characters at the end of the string.
.PP
\f[B]print([IoDevice,] Sexpr) -> ok\f[R]
.PP
Print the s-expr \f[V]Sexpr\f[R] to the standard output
(\f[V]IoDevice\f[R]).
.PP
\f[B]print1(Sexpr) -> DeepCharList\f[R]
.PP
Return the list of characters which represent the s-expr
\f[V]Sexpr\f[R].
.PP
\f[B]prettyprint([IoDevice,] Sexpr) -> ok\f[R]
.PP
Pretty print the s-expr \f[V]Sexpr\f[R] to the standard output
(\f[V]IoDevice\f[R]).
.PP
\f[B]prettyprint1(Sexpr) -> DeepCharList\f[R]
.PP
\f[B]prettyprint1(Sexpr, Depth) -> DeepCharList\f[R]
.PP
\f[B]prettyprint1(Sexpr, Depth, Indentation) -> DeepCharList\f[R]
.PP
\f[B]prettyprint1(Sexpr, Depth, Indentation, LineLength) ->
DeepCharList\f[R]
.PP
Return the list of characters which represents the prettyprinted s-expr
\f[V]Sexpr\f[R].
Default values for \f[V]Depth\f[R] is 30, \f[V]Indentation\f[R] is 0 and
\f[V]LineLength\f[R] is 80.
.PP
\f[B]format([IoDevice,] Format, Args) -> ok\f[R]
.PP
\f[B]fwrite([IoDevice,] Format, Args) -> ok\f[R]
.PP
\f[B]format1(Format, Args) -> DeepCharList\f[R]
.PP
\f[B]fwrite1(Format, Args) -> DeepCharList\f[R]
.PP
Print formatted output.
The following commands are valid in the format string:
.IP \[bu] 2
\f[B]\[ti]w, \[ti]W\f[R] - print LFE terms
.IP \[bu] 2
\f[B]\[ti]p, \[ti]P\f[R] - prettyprint LFE terms
.IP \[bu] 2
\f[B]\[ti]s\f[R] - print a string
.IP \[bu] 2
\f[B]\[ti]e, \[ti]f, \[ti]g\f[R] - print floats
.IP \[bu] 2
\f[B]\[ti]b, \[ti]B\f[R] - based integers
.IP \[bu] 2
\f[B]\[ti]x, \[ti]X\f[R] - based integers with a prefix
.IP \[bu] 2
\f[B]\[ti]+, \[ti]#\f[R] - based integers in vanilla erlang format
.IP \[bu] 2
\f[B]\[ti]c, \[ti]n, \[ti]i\f[R]
.PP
Currently they behave as for vanilla erlang except that
\f[V]\[ti]w\f[R], \f[V]\[ti]W\f[R], \f[V]\[ti]p\f[R], \f[V]\[ti]P\f[R]
print the terms as LFE sexprs.
.PP
\f[B]read_file(FileName) -> {ok,[Sexpr]} | {error,ErrorInfo}\f[R]
.PP
Read the file \f[V]Filename\f[R] returning a list of s-exprs (as it
should be).
.PP
\f[B]parse_file(FileName) -> {ok,[FileSexpr]} | {error,ErrorInfo}\f[R]
.PP
where
.IP
.nf
\f[C]
FileSexpr = filesexpr()
\f[R]
.fi
.PP
Read the file \f[V]Filename\f[R] returning a list of pairs containing
s-expr and line number of the start of the s-expr.
.PP
\f[B]scan_sexpr(Cont, Chars [,Line]) ->
{done,Ret,RestChars}|{more,Cont1}\f[R]
.PP
This is a re-entrant call which scans tokens from the input and returns
a parsed sepxr.
If there are enough characters to parse a sexpr or it detects and error
then it returns \f[V]{done,...}\f[R] otherwise it returns
\f[V]{more,Cont}\f[R] where \f[V]Cont\f[R] is used in the next call to
\f[V]scan_sexpr\f[R] with more characters to try and parse a sexpr.
This is continued until a sexpr has been parsed.
\f[V]Cont\f[R] is initially \f[V][]\f[R].
.PP
It is not designed to be called directly by an application but used
through the i/o system where it can typically be called in an
application by:
.PP
\f[V]io:request(In, {get_until,unicode,Prompt,Module,scan_sexpr,[Line]})\f[R]
.SH ERROR INFORMATION
.PP
The \f[V]ErrorInfo\f[R] mentioned above is the standard
\f[V]ErrorInfo\f[R] structure which is returned from all IO modules.
It has the following format:
.PP
\f[B]{ErrorLine,Module,ErrorDescriptor}\f[R]
.PP
A string describing the error is obtained with the following call:
.IP
.nf
\f[C]
apply(Module, format_error, ErrorDescriptor)
\f[R]
.fi
.SH AUTHORS
Robert Virding.
