'\" t
.\" Automatically generated by Pandoc 2.11.2
.\"
.TH "lfe_types" "7" "2021" "" ""
.hy
.SH NAME
.PP
lfe_types - LFE Types and Functions Specifications
.SH TYPES
.PP
This is a description of the type syntax.
.PP
.TS
tab(@);
l l.
T{
LFE type
T}@T{
Erlang type
T}
_
T{
\f[C](none)\f[R]
T}@T{
\f[C]none()\f[R]
T}
T{
\f[C](any)\f[R]
T}@T{
\f[C]any()\f[R]
T}
T{
\f[C](atom)\f[R]
T}@T{
\f[C]atom()\f[R]
T}
T{
\f[C](integer)\f[R]
T}@T{
\f[C]integer()\f[R]
T}
T{
\f[C](range i1 i2)\f[R]
T}@T{
\f[C]I1..I2\f[R]
T}
T{
\f[C](float)\f[R]
T}@T{
\f[C]float()\f[R]
T}
T{
\f[C](bitstring m n)\f[R]
T}@T{
\f[C]<<_:M,_:_*N>>\f[R]
T}
T{
\f[C](binary)\f[R]
T}@T{
\f[C]<<_:0,_:_*8>>\f[R]
T}
T{
\f[C](bitstring)\f[R]
T}@T{
\f[C]<<_:0,_:_*1>>\f[R]
T}
T{
\f[C]...\f[R]
T}@T{
\f[C]...\f[R]
T}
T{
\f[C](lambda any <type>)\f[R]
T}@T{
\f[C]fun((...) -> <type>)\f[R]
T}
T{
\f[C](lambda () <type>)\f[R]
T}@T{
\f[C]fun(() -> <type>)\f[R]
T}
T{
\f[C](lambda (<tlist>) <type>)\f[R]
T}@T{
\f[C]fun((<tlist>) -> <type>)\f[R]
T}
T{
\f[C](map)\f[R]
T}@T{
\f[C]map()\f[R]
T}
T{
\f[C]#M()\f[R]
T}@T{
\f[C]#{}\f[R]
T}
T{
\f[C]#M(<key> <value> ...)\f[R]
T}@T{
\f[C]#{<pairlist>}\f[R]
T}
T{
\f[C](tuple)\f[R]
T}@T{
\f[C]tuple()\f[R]
T}
T{
\f[C]#()\f[R]
T}@T{
\f[C]{}\f[R]
T}
T{
\f[C]#(<tlist>)\f[R]
T}@T{
\f[C]{<tlist>}\f[R]
T}
T{
\f[C](UNION <tlist>)\f[R]
T}@T{
\f[C]<type> | <type>\f[R]
T}
.TE
.PP
Apart from the predefined types in the Erlang type system we also have
the following predefined types which cannot be redefined:
\f[C]UNION\f[R], \f[C]call\f[R], \f[C]lambda\f[R] and \f[C]range\f[R].
The usage of \f[C]bitstring\f[R], \f[C]tuple\f[R] and \f[C]map\f[R] have
also been extended.
.PP
Note that the type \f[C]#M()\f[R] is the empty map and the type
\f[C]#()\f[R] is the empty tuple.
We can still use the older \f[C](map <key valuelist>)\f[R] and
\f[C](tuple <tlist>)\f[R] formats when declaring types for maps and
tuples.
.PP
The general form of bitstrings is \f[C](bitstring m n)\f[R] which
denotes a bitstring which starts with \f[C]m\f[R] bits and continues
with segments of \f[C]n\f[R] bits.
\f[C](binary)\f[R] is a short form for a sequence of bytes while
\f[C](bitstring)\f[R] is a short form for a sequence of bits.
There is currently no short form for an empty binary,
\f[C](bitstring 0 0)\f[R] must be used.
.SS Type Declarations of User-Defined Types
.PP
\f[B](deftype (type-name) type-def)\f[R]
.PP
\f[B](defopaque (type-name) type-def)\f[R]
.PP
\f[B](deftype (type-name par1 par2) type-def)\f[R]
.PP
\f[B](defopaque (type-name par1 par2) type-def)\f[R]
.PP
For unparameterised types the parentheses around the type name are
optional.
An example:
.IP
.nf
\f[C]
(deftype foo (tuple \[aq]foo (integer) (list)))

(deftype bar (tuple \[aq]bar (integer) (list)))
\f[R]
.fi
.SS Type Information in Record Declarations
.PP
\f[B](defrecord rec (field1 default1 type1) (field2 default2)
(field3))\f[R]
.PP
Fields with type annotations \f[I]MUST\f[R] give a default value and
fields without type annotations get the default type \f[C](any)\f[R].
.SH SPECIFICATIONS
.SS Type specifications of User-Defined Functions
.PP
\f[B](defspec (func-name arity) function-spec \&...)\f[R]
.PP
where
.IP
.nf
\f[C]
function-spec = (arg-type-list ret-type)
function-spec = (arg-type-list ret-type constraint-list)
arg-type-list = (arg-type ...)
constraint-list = (constraint ...)
constraint = (var var-type)
\f[R]
.fi
.PP
For multiple types add more function specs.
The parentheses around the function name and the arity are optional.
For example from the docs:
.IP
.nf
\f[C]
(defspec foo ([(pos_integer)] (pos_integer)))

(defspec (foo 1)
  ([(pos_integer)] (pos_integer))
  ([(integer)] (integer)))

(defspec (remove-if 2)
  ([(lambda ((any)) (boolean)) (list)] (list)))
\f[R]
.fi
.PP
Or with constraints:
.IP
.nf
\f[C]
(defspec id ((X) X ((X (tuple)))))

(defspec (foo 1)
  ([(tuple X (integer))] X ((X (atom))))
  ([(list Y)] Y ((Y (number)))))

(defspec (remove-if 2)
  ([pred (list)] (list) [(pred (lambda ((any)) (boolean)))]))
\f[R]
.fi
.PP
Note that a constraint variable doesn\[cq]t need to start with an
upper-case like an Erlang variable, though in some case it may be easier
to read.
.PP
Note we are using the alternate list form with \f[C][ ]\f[R] instead of
parentheses to make it easier to see the function arguments.
.SH Types and function specifications in the module definition
.PP
Types can also be defined in the module declaration, for example:
.IP
.nf
\f[C]
(defmodule this-module
  ...
  (type ((foo-type) (tuple \[aq]foo (integer) (list)))
        ((bar-type) (tuple \[aq]bar (integer) (list))))
  (spec ((foo 1) ([(integer)] (foo-type)))
        ((id 1) ([x] x ((x (tuple))))))
  ...)
\f[R]
.fi
.SH AUTHORS
Robert Virding.
