.\" Automatically generated by Pandoc 2.11.2
.\"
.TH "lfe_cl" "3" "2017" "" ""
.hy
.SH NAME
.PP
lfe_cl - LFE Common Lisp interface library
.SH SYNOPSIS
.PP
This module provides a set of Common Lisp functions and macros for use
in LFE.
The definitions closely follow the CL definitions and won\[cq]t be
documented here.
.SH DATA TYPES
.PP
The boolean values used here are the standard LFE \f[C]true\f[R] and
\f[C]false\f[R] and \f[B]NOT\f[R] the Common Lisp values.
.SH EXPORTS
.SS Boolean conversion functions
.PP
\f[B]make-lfe-bool cl-value\f[R]
.PP
\f[B]make-cl-bool lfe-bool\f[R]
.SS Control structures
.PP
\f[B]\f[CB]do vars (end-test result) body                            [macro]\f[B]\f[R]
.PP
The value of \f[C]body\f[R] is bound the variable \f[C]do-state\f[R]
which can be used when updating vars and in the \f[C]end-test\f[R].
This is the only way to get a value out of the body.
.PP
\f[B]mapcar function list\f[R]
.PP
\f[B]maplist function list\f[R]
.PP
\f[B]mapc function list\f[R]
.PP
\f[B]mapl function list\f[R]
.SS Symbol functions
.PP
\f[B]symbol-plist symbol\f[R]
.PP
\f[B]symbol-name symbol\f[R]
.PP
\f[B]get symbol pname\f[R]
.PP
\f[B]get symbol pname default\f[R]
.PP
\f[B]getl symbol pname-list\f[R]
.PP
\f[B]putprop symbol value pname\f[R]
.PP
\f[B]remprop symbol pname\f[R]
.PP
Atoms (symbols) in LFE don\[cq]t have property lists associated with
them.
However, here we have experimented with having a global ETS table
\f[C]lfe-symbol-plist\f[R] which associates an atom with a property
list.
This is very unLFEy, but quite fun.
.SS Property list functions
.PP
\f[B]getf plist pname\f[R]
.PP
\f[B]getf plist pname default\f[R]
.PP
\f[B]putf plist value pname\f[R]
.PP
\f[B]remf plist pname\f[R]
.PP
\f[B]get-properties plist pname-list\f[R]
.PP
The function \f[C]putf/3\f[R] does not exist in Common Lisp but is
included to complete the operations on property lists.
.SS Simple sequence functions
.PP
\f[B]elt index sequence\f[R]
.PP
\f[B]length sequence\f[R]
.PP
\f[B]reverse sequence\f[R]
.SS Concatenation, mapping and reducing functions
.PP
\f[B]some predicate sequence\f[R]
.PP
\f[B]every predicate sequence\f[R]
.PP
\f[B]notany predicate sequence\f[R]
.PP
\f[B]notevery predicate sequence\f[R]
.PP
\f[B]reduce function sequence\f[R]
.PP
\f[B]reduce function sequence \[cq]initial-value x\f[R]
.PP
\f[B]reduce function sequence \[cq]from-end \[cq]true\f[R]
.PP
\f[B]reduce function sequence \[cq]initial-value x \[cq]from-end
\[cq]true\f[R]
.SS Modifying sequences
.PP
\f[B]remove item sequence\f[R]
.PP
\f[B]remove-if predicate sequence\f[R]
.PP
\f[B]remove-if-not predicate sequence\f[R]
.PP
\f[B]remove-duplicates sequence\f[R]
.PP
\f[B]substitute new old sequence\f[R]
.PP
\f[B]substitute-if predicate sequence\f[R]
.PP
\f[B]substitute-if-not predicate sequence\f[R]
.SS Searching sequences
.PP
\f[B]find item sequence\f[R]
.PP
\f[B]find-if predicate sequence\f[R]
.PP
\f[B]find-if-not predicate sequence\f[R]
.PP
\f[B]find-duplicates sequence\f[R]
.PP
\f[B]position item sequence\f[R]
.PP
\f[B]position-if predicate sequence\f[R]
.PP
\f[B]position-if-not predicate sequence\f[R]
.PP
\f[B]position-duplicates sequence\f[R]
.PP
\f[B]count item sequence\f[R]
.PP
\f[B]count-if predicate sequence\f[R]
.PP
\f[B]count-if-not predicate sequence\f[R]
.SS Lists
.PP
\f[B]car list\f[R]
.PP
\f[B]first list\f[R]
.PP
\f[B]cdr list\f[R]
.PP
\f[B]rest list\f[R]
.PP
\f[B]nth index list\f[R]
.PP
\f[B]nthcdr index list\f[R]
.PP
\f[B]last list\f[R]
.PP
\f[B]butlast list\f[R]
.SS Substitution of expressions
.PP
\f[B]subst new old tree\f[R]
.PP
\f[B]subst-if new test tree\f[R]
.PP
\f[B]subst-if-not new test tree\f[R]
.PP
\f[B]sublis alist tree\f[R]
.SS Lists as sets
.PP
\f[B]member item list\f[R]
.PP
\f[B]member-if predicate list\f[R]
.PP
\f[B]member-if-not predicate list\f[R]
.PP
\f[B]adjoin item list\f[R]
.PP
\f[B]union list list\f[R]
.PP
\f[B]intersection list list\f[R]
.PP
\f[B]set-difference list list\f[R]
.PP
\f[B]set-exclusive-or list list\f[R]
.PP
\f[B]subsetp list list\f[R]
.SS Association list functions
.PP
\f[B]acons key data alist\f[R]
.PP
\f[B]pairlis list list\f[R]
.PP
\f[B]pairlis list list alist\f[R]
.PP
\f[B]assoc key alist\f[R]
.PP
\f[B]assoc-if predicate alost\f[R]
.PP
\f[B]assoc-if-not predicate alost\f[R]
.PP
\f[B]rassoc key alist\f[R]
.PP
\f[B]rassoc-if predicate alost\f[R]
.PP
\f[B]rassoc-if-not predicate alost\f[R]
.SS Types
.PP
\f[B]type-of object\f[R]
.PP
\f[B]coerce object type\f[R]
.SS Type testing macros
.PP
There is an include file which developers may which to utilize in their
LFE programs: \f[C](include-lib \[dq]lfe/include/cl.lfe\[dq])\f[R].
Currently this offers Common Lisp predicates, but may include other
useful macros and functions in the future.
The provided predicate macros wrap the various \f[C]is_*\f[R] Erlang
functions; since these are expanded at compile time, they are usable in
guards.
It includes the following:
.PP
\f[B]alivep x\f[R]
.PP
\f[B]atomp x\f[R]
.PP
\f[B]binaryp x\f[R]
.PP
\f[B]bitstringp x\f[R]
.PP
\f[B]boolp x\f[R]
.PP
\f[B]booleanp x\f[R]
.PP
\f[B]builtinp x\f[R]
.PP
\f[B]floatp x\f[R]
.PP
\f[B]funcp x\f[R]
.PP
\f[B]functionp x\f[R]
.PP
\f[B]intp x\f[R] and \f[B]integerp x\f[R]
.PP
\f[B]listp x\f[R]
.PP
\f[B]mapp x\f[R]
.PP
\f[B]numberp x\f[R]
.PP
\f[B]pidp x\f[R]
.PP
\f[B]process-alive-p x\f[R]
.PP
\f[B]recordp x tag\f[R]
.PP
\f[B]recordp x tag size\f[R]
.PP
\f[B]refp x\f[R]
.PP
\f[B]referencep x\f[R]
.PP
\f[B]tuplep x\f[R]
.SH AUTHORS
Robert Virding.
