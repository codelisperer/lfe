.\" Automatically generated by Pandoc 2.11.2
.\"
.TH "lfe" "1" "2008-2020" "" ""
.hy
.SH NAME
.PP
lfe - Lisp Flavoured Erlang (LFE) shell
.SH SYNOPSIS
.PP
\f[C]lfe\f[R] is a simple LFE repl (read-eval-print loop) in which you
can enter sexprs which then are evaluated and the value printed.
You can also define local functions and macros as well as set variables.
It can read commands either from the standard input or from a file.
.PP
The LFE repl is implemented in the module \f[C]lfe_shell\f[R].
.SH BUILT-IN SHELL FUNCTIONS
.PP
These are defined as normal functions and macros and can be called from
anywhere in the shell.
They can even be redefined.
They can also be explicitly called (: lfe_shell \&...).
.PP
\f[B](c File [Options])\f[R]
.PP
Compile and load an LFE file.
Assumes default extension \f[C].lfe\f[R].
.PP
\f[B](: c Command Arg \&...)\f[R]
.PP
\f[B](c:Command Arg \&...)\f[R]
.PP
All the commands in the standard Erlang shell can be reached in this
way.
.PP
\f[B](cd Dir)\f[R]
.PP
Change the working directory.
.PP
\f[B](clear)\f[R]
.PP
Clear the REPL output.
.PP
\f[B](ec File [Options])\f[R]
.PP
Compile and load an Erlang file.
.PP
\f[B](ep Expr [Depth])\f[R]
.PP
\f[B](epp Expr [Depth])\f[R]
.PP
Print/prettyprint a value in Erlang form to either the specified depth
or if no value is given the full depth.
.PP
\f[B](flush)\f[R]
.PP
Flush any messages sent to the shell.
.PP
\f[B](h)\f[R]
.PP
\f[B](help)\f[R]
.PP
Print usage info.
.PP
\f[B](h Mod)\f[R]
.PP
\f[B](h Mod Mac)\f[R]
.PP
\f[B](h Mod Fun Arity)\f[R]
.PP
Print out help information of a module/macro/function.
.PP
\f[B](i [(list Pid \&...)])\f[R]
.PP
Print information about a list of pids.
If no list is given then print information about currently running
processes in the system.
.PP
\f[B](i x y z)\f[R]
.PP
Print information about the about #Pid<x.y.z>
.PP
\f[B](l Module \&...)\f[R]
.PP
Load modules.
.PP
\f[B](ls)\f[R]
.PP
\f[B](ls dir)\f[R]
.PP
List files in a directory.
If no directory is given then list files in the current directory.
.PP
\f[B](m [Module \&...])\f[R]
.PP
Print out module information.
If no modules are given then print information about all modules.
.PP
\f[B](p Expr [Depth])\f[R]
.PP
\f[B](pp Expr [Depth])\f[R]
.PP
Print/prettyprint a value to either the specified depth or if no value
is given the full depth.
.PP
\f[B](pid x y z)\f[R]
.PP
Create a pid from x, y, z.
.PP
\f[B](pwd)\f[R]
.PP
Print the current working directory.
.PP
\f[B](q)\f[R]
.PP
Quit - shorthand for \f[C]init:stop/0\f[R].
.PP
\f[B](regs)\f[R]
.PP
Print information about the registered processes in the system.
.SH BUILT-IN SHELL COMMANDS
.PP
These are special forms which are only recognised at the top-level in
shell input.
The cannot be redefined.
.PP
\f[B](reset-environment)\f[R]
.PP
Resets the environment to its initial state.
This will clear all variables, functions and macros that have been set.
.PP
\f[B](run File)\f[R]
.PP
Execute all the shell commands in File.
All defined variables, functions and macros will be saved in the
environment if there are no errors.
.PP
\f[B](set Pattern Expr)\f[R]
.PP
\f[B](set Pattern (when Guard) Expr)\f[R]
.PP
Evaluate Expr and match the result with Pattern binding variables in it.
These variables can then be used in the shell and also rebound in
another set.
.PP
\f[B](slurp File)\f[R]
.PP
Slurp in a source LFE file and makes all functions and macros defined in
the file available in the shell.
Only one file can be slurped at a time and slurping a new file basically
does an unslurp first.
.PP
\f[B](unslurp)\f[R]
.PP
Revert back to the state before the last slurp removing all function and
macro definitions both in the slurped file and defined in the shell
since then.
.SH SHELL FUNCTIONS AND MACROS
.PP
Functions and macros can be defined in the shell.
These will only be local to the shell and cannot be called from modules.
The forms are the standard forms for defining functions and macros.
.PP
\f[B](defun Fun \&...)\f[R]
.PP
Define a function in the shell.
.PP
\f[B](defmacro Macro \&...)\f[R]
.PP
Define a macro in the shell.
.SH BUILT-IN SHELL VARIABLES
.PP
\f[B]\f[CB]+\f[B], \f[CB]++\f[B], \f[CB]+++\f[B]\f[R]
.PP
The three previous expressions input.
.PP
\f[B]\f[CB]*\f[B], \f[CB]**\f[B], \f[CB]***\f[B]\f[R]
.PP
The values of the previous three expressions.
.PP
\f[B]\f[CB]-\f[B]\f[R]
.PP
The current expression input.
.SH SHELL ENVIRONMENT
.PP
The shell maintains an environment of local function and macro
definitions, and variable bindings.
The environment can be accessed using the built-in shell variable $ENV.
This can be useful when calling functions like macroexpand and
macro-function which unless an explicit environment is given will only
search the default environment.
.SH STARTING THE LFE SHELL
.PP
After installing the best way is probably to start Erlang directly
running the LFE shell with:
.IP
.nf
\f[C]
lfe [flags]
\f[R]
.fi
.PP
From a normal Erlang shell the best way to start the shell is by
calling:
.IP
.nf
\f[C]
17> lfe_shell:server().
\f[R]
.fi
.PP
Giving the user switch commands:
.IP
.nf
\f[C]
--> s lfe_shell
--> c
\f[R]
.fi
.PP
will create a job running the LFE shell and connect to it.
This also works when starting a remote shell.
.PP
Flags that LFE recognizes include the following:
.IP \[bu] 2
\f[C]-nobanner\f[R] - starts LFE without showing the banner
.IP \[bu] 2
\f[C]-h\f[R] or \f[C]--help\f[R] - provides command line usage help
.IP \[bu] 2
\f[C]-e\f[R] or \f[C]-eval\f[R] - evaluates a given sexpr in a string
.IP \[bu] 2
\f[C]-prompt\f[R] - users may supply a value here to override the
default \f[C]lfe>\f[R] prompt; note that \f[C]-prompt classic\f[R] will
set the prompt to the original \f[C]>\f[R] and \f[C]-prompt\f[R] with no
associated value will cause no prompt to be displayed at all.
These also work when node names are provided (with either
\f[C]-sname\f[R] or \f[C]-name\f[R]).
Furthermore, users may override the default formatting of node names in
prompts by providing a prompt value containing the string
\f[C]\[ti]node\f[R] (which will be substituted with the actual name of
the node).
.PP
There can be multiple string expressions to be evaluated; each one must
be prefixed with an \f[C]-e\f[R] or \f[C]-eval\f[R].
String expressions are run in the LFE repl so shell commands and
functions are allowed.
They are all run in the same invocation of the repl so:
.IP
.nf
\f[C]
$ lfe -e \[dq](set aaa 42)\[dq] -e \[dq](set bbb 84)\[dq] -e \[dq](pp (tuple aaa bbb))\[dq]
#(42 84)
\f[R]
.fi
.PP
If there are string expressions then the LFE repl will \f[C]not\f[R] be
run.
.SH RUNNING LFE SHELL SCRIPTS
.PP
The LFE shell can also be directly called to run LFE shell scripts with:
.IP
.nf
\f[C]
lfe [flags] file [args]
\f[R]
.fi
.PP
This will start the shell, run a script with LFE shell commands and then
terminate the shell.
The following built-in variables are also bound:
.PP
\f[B]script-name\f[R]
.PP
The name of the script file as a string.
.PP
\f[B]script-args\f[R]
.PP
A list of the arguments to the script as strings.
If no arguments have been given then this will be an empty list.
.PP
Note that if there are any string expressions to be evaluated then these
must come before the name of the script file and its arguments.
These expressions will be evaluated before the script and the script
will use the environment from the string expressions.
.PP
It is possible to run both string expressions and an LFE shell script
and they are then run in the same LFE repl.
.SH SEE ALSO
.PP
\f[B]lfescript(1)\f[R], \f[B]lfe_guide(7)\f[R] \f[B]lfe_doc(3)\f[R]
.SH AUTHORS
Robert Virding.
