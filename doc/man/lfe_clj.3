.\" Automatically generated by Pandoc 2.11.2
.\"
.TH "lfe_clj" "3" "2015-2016" "" ""
.hy
.SH NAME
.PP
clj - LFE Clojure interface library.
.SH SYNOPSIS
.PP
This module provides Clojure-inspired functions and macros for use in
LFE.
.SH EXPORTS
.PP
N.B.
Instead of making fully-qualified calls to the macros exported from
\f[I]clj\f[R], you may
\f[C](include-lib \[dq]lfe/include/clj.lfe\[dq])\f[R] and then call them
directly, e.g.
.IP
.nf
\f[C]
(include-lib \[dq]lfe/include/clj.lfe\[dq])

(-> 2 (+ 2) (=:= 4)) ; \[aq]true
\f[R]
.fi
.SS Function Macros
.PP
\f[B](defn name [arg \&...] {{doc-string}} \&...)\f[R]
.PP
\f[B](defn {{doc-string}} ([argpat \&...] \&...))\f[R]
.PP
Define and automatically export a function.
.PP
\f[B](defn- name [arg \&...] {{doc-string}} \&...)\f[R]
.PP
\f[B](defn- {{doc-string}} ([argpat \&...] \&...))\f[R]
.PP
Equivalent to \f[B]defun\f[R].
.PP
\f[B](fn (arg \&...) \&...)\f[R]
.PP
Equivalent to \f[C]lambda\f[R].
.SS Threading Macros
.PP
Note: The original versions were copied from Tim Dysinger\[cq]s lfesl
repo here:
.IP
.nf
\f[C]
https://github.com/lfex/lfesl/blob/master/include/thread.lfe
\f[R]
.fi
.PP
They have since been modified to be safely exportable.
.PP
\f[B](-> \&...)\f[R]
.PP
Thread first.
.PP
Example usage, demonstrating ordering:
.IP
.nf
\f[C]
> (set o \[aq](#(a 1) #(b 2) #(c 3)))
(#(a 1) #(b 2) #(c 3))
> (clj:-> o
>         (++ \[aq](#(d 4)))
>         (++ \[aq](#(e 5)))
>         (++ \[aq](#(f 6))))
(#(a 1) #(b 2) #(c 3) #(d 4) #(e 5) #(f 6))
\f[R]
.fi
.PP
Note that the use of \f[B]->\f[R] in this example results in each
successive value being \f[I]appended\f[R] to the input list.
.PP
Another example showing how this works:
.IP
.nf
\f[C]
> (lists:sublist
>   (lists:reverse
>     (lists:sort
>       (lists:merge
>         (string:tokens
>           (string:to_upper \[dq]a b c d e\[dq])
>           \[dq] \[dq])
>         \[aq](\[dq]X\[dq] \[dq]F\[dq] \[dq]L\[dq]))))
>   2 3)
(\[dq]L\[dq] \[dq]F\[dq] \[dq]E\[dq])
\f[R]
.fi
.PP
Can be rewritten as this:
.IP
.nf
\f[C]
> (clj:-> \[dq]a b c d e\[dq]
>         (string:to_upper)
>         (string:tokens \[dq] \[dq])
>         (lists:merge \[aq](\[dq]X\[dq] \[dq]F\[dq] \[dq]L\[dq]))
>         (lists:sort)
>         (lists:reverse)
>         (lists:sublist 2 3))
(\[dq]L\[dq] \[dq]F\[dq] \[dq]E\[dq])
\f[R]
.fi
.PP
\f[B](->> \&...)\f[R]
.PP
Thread last.
.PP
Example usage, demonstrating ordering:
.IP
.nf
\f[C]
> (set o \[aq](#(a 1) #(b 2) #(c 3)))
(#(a 1) #(b 2) #(c 3))
> (clj:->> o
>          (++ \[aq](#(d 4)))
>          (++ \[aq](#(e 5)))
>          (++ \[aq](#(f 6))))
(#(f 6) #(e 5) #(d 4) #(a 1) #(b 2) #(c 3))
\f[R]
.fi
.PP
Note that the use of \f[B]->>\f[R] in this example results in each
successive value being \f[I]prepended\f[R] to the input list.
.PP
Another example showing how this:
.IP
.nf
\f[C]
> (lists:foldl #\[aq]+/2 0
>   (clj:take 10
>     (lists:filter
>       (clj:comp #\[aq]clj:even?/1 #\[aq]clj:round/1)
>       (lists:map
>         (lambda (x)
>           (math:pow x 2))
>         (clj:seq 42)))))
1540.0
\f[R]
.fi
.PP
Can be rewritten as this:
.IP
.nf
\f[C]
> (clj:->> (clj:seq 42)
>          (lists:map (lambda (x) (math:pow x 2)))
>          (lists:filter (clj:comp #\[aq]clj:even?/1 #\[aq]clj:round/1))
>          (clj:take 10)
>          (lists:foldl #\[aq]+/2 0))
1540.0
\f[R]
.fi
.PP
\f[B](as-> expr name . sexps)\f[R]
.PP
Bind \f[C]name\f[R] to \f[C]expr\f[R], evaluate the first \f[C]sexp\f[R]
in the lexical context of that binding, then bind \f[C]name\f[R] to that
result, repeating for each successive \f[C]sexp\f[R] in \f[C]sexps\f[R],
returning the result of the last \f[C]sexp\f[R].
.PP
\f[B](cond-> expr . clauses)\f[R]
.PP
Given an \f[C]expr\f[R]ession and a set of \f[C]test\f[R]/\f[C]sexp\f[R]
pairs, thread \f[C]x\f[R] (via \f[B]->\f[R]) through each \f[C]sexp\f[R]
for which the corresponding \f[C]test\f[R] expression is truthy,
i.e.\ neither \f[C]\[aq]false\f[R] nor \f[C]\[aq]undefined\f[R].
Note that, unlike \f[B]cond\f[R] branching, \f[B]cond->\f[R] threading
does not short circuit after the first truthy test expression.
.PP
\f[B](cond->> expr . clauses)\f[R]
.PP
Given an \f[C]expr\f[R]ession and a set of \f[C]test\f[R]/\f[C]sexp\f[R]
pairs, thread \f[C]x\f[R] (via \f[B]->>\f[R]) through each
\f[C]sexp\f[R] for which the corresponding \f[C]test\f[R] expression is
truthy, i.e.\ neither \f[C]\[aq]false\f[R] nor \f[C]\[aq]undefined\f[R].
Note that, unlike \f[B]cond\f[R] branching, \f[B]cond->>\f[R] threading
does not short circuit after the first truthy \f[C]test\f[R] expression.
.PP
\f[B](some-> x . sexps)\f[R]
.PP
When \f[C]x\f[R] is not \f[C]\[aq]undefined\f[R], thread it into the
first \f[C]sexp\f[R] (via \f[B]->\f[R]), and when that result is not
\f[C]\[aq]undefined\f[R], through the next, etc.
.PP
\f[B](some->> x . sexps)\f[R]
.PP
When \f[C]x\f[R] is not \f[C]\[aq]undefined\f[R], thread it into the
first \f[C]sexp\f[R] (via \f[B]->>\f[R]), and when that result is not
\f[C]\[aq]undefined\f[R], through the next, etc.
.SS Conditional Macros
.PP
\f[B](if-let ((patt test)) then {{else}})\f[R]
.PP
If \f[C]test\f[R] evaluates to anything other than \f[C]\[aq]false\f[R]
or \f[C]\[aq]undefined\f[R], evaluate \f[C]then\f[R] with \f[C]patt\f[R]
bound to the value of \f[C]test\f[R], otherwise \f[C]else\f[R], if
supplied, else \f[C]\[aq]undefined\f[R].
.PP
\f[B](iff-let ((patt test)) . body)\f[R]
.PP
When \f[C]test\f[R] evaluates to anything other than
\f[C]\[aq]false\f[R] or \f[C]\[aq]undefined\f[R], evaluate
\f[C]body\f[R] with \f[C]patt\f[R] bound to the value of \f[C]test\f[R],
otherwise return \f[C]\[aq]undefined\f[R].
.PP
\f[B](condp pred expr . clauses)\f[R]
.PP
Given a binary predicate, an expression and a set of clauses of the
form:
.IP
.nf
\f[C]
test-expr result-expr

test-expr >> result-fn
\f[R]
.fi
.PP
where \f[C]result-fn\f[R] is a unary function, if
\f[C](pred test-expr expr)\f[R] returns anything other than
\f[C]\[aq]undefined\f[R] or \f[C]\[aq]false\f[R], the clause is a match.
.PP
If a binary clause matches, return \f[C]result-expr\f[R].
If a ternary clause matches, call \f[C]result-fn\f[R] with the result of
the predicate and return the result.
.PP
If no clause matches and a single default expression is given after the
clauses, return it.
If no default expression is given and no clause matches, throw a
\f[C]no-matching-clause\f[R] error.
.PP
\f[B](if-not test then)\f[R]
.PP
\f[B](if-not test then else)\f[R]
.PP
If \f[C]test\f[R] evaluates to \f[C]\[aq]false\f[R] or
\f[C]\[aq]undefined\f[R], evaluate and return \f[C]then\f[R], otherwise
\f[C]else\f[R], if supplied, else \f[C]\[aq]undefined\f[R].
.PP
\f[B](iff test . body)\f[R]
.PP
Like Clojure\[cq]s \f[C]when\f[R].
If \f[C]test\f[R] evaluates to anything other than \f[C]\[aq]false\f[R]
or \f[C]\[aq]undefined\f[R], evaluate \f[C]body\f[R] in an implicit
\f[C]progn\f[R].
.PP
\f[B](when-not test . body)\f[R]
.PP
If \f[C]test\f[R] evaluates to \f[C]\[aq]false\f[R] or
\f[C]\[aq]undefined\f[R], evaluate \f[C]body\f[R] in an implicit
\f[C]progn\f[R].
Otherwise return \f[C]\[aq]undefined\f[R].
.PP
\f[B](not= x)\f[R]
.PP
\f[B](not= x y)\f[R]
.PP
\f[B](not= x y . more)\f[R]
.PP
Same as \f[C](not (== ...))\f[R].
.SS Predicate Macros
.PP
Allowed in guards, unless otherwise stated.
.PP
\f[B](tuple? x)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is a tuple.
.PP
\f[B](atom? x)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is an atom.
.PP
\f[B](binary? x)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is a binary.
.PP
\f[B](bitstring? x)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is a bitstring.
.PP
\f[B](boolean? x)\f[R]
.PP
\f[B](bool? x)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is a boolean.
.PP
\f[B](float? x)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is a float.
.PP
\f[B](function? f)\f[R]
.PP
\f[B](func? f)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is a function.
.PP
\f[B](function? f n)\f[R]
.PP
\f[B](func? f n)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]f\f[R] is an \f[C]n\f[R]-ary
function.
.PP
\f[B](integer? x)\f[R]
.PP
\f[B](int? x)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is an integer.
.PP
\f[B](number? x)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is a number.
.PP
\f[B](record? x record-tag)\f[R]
.PP
\f[B](record? x record-tag size)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is a tuple and its first
element is \f[C]record-tag\f[R].
If \f[C]size\f[R] is given, check that \f[C]x\f[R] is a
\f[C]record-tag\f[R] record of size \f[C]size\f[R].
.PP
N.B.
\f[B]record?/2\f[R] may yield unexpected results, due to difference
between the Erlang and LFE compilers.
As such, whenever possible, prefer \f[B]record?/3\f[R].\[dq]
.PP
\f[B](reference? x)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is a reference.
.PP
\f[B](map? x)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is a map.
Return \f[C]\[aq]false\f[R] on versions of Erlang without maps.
.PP
\f[B](undefined? x)\f[R]
.PP
\f[B](undef? x)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is the atom
\f[C]\[aq]undefined\f[R].
.PP
\f[B](nil? x)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is the atom \f[C]\[aq]nil\f[R]
or the empty list.
.PP
\f[B](true? x)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is the atom
\f[C]\[aq]true\f[R].
.PP
\f[B](false? x)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is the atom
\f[C]\[aq]false\f[R].
.PP
\f[B](falsy? x)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is one of the atoms
\f[C]\[aq]false\f[R] and \f[C]\[aq]undefined\f[R].
.PP
\f[B](odd? x)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is odd.
.PP
\f[B](even? x)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is even.
.PP
\f[B](zero? x)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is zero.
.PP
\f[B](pos? x)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is greater than zero.
.PP
\f[B](neg? x)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is less than zero.
.PP
\f[B](identical? x)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is exactly equal to
\f[C]y\f[R].
.SS Other Macros
.PP
\f[B](str x1, x2 \&... xn)\f[R]
.PP
Given arbitrary number of arguments, return a string consisting of each
of their string representations.
.PP
N.B.
Because Erlang characters are represented as integers, this will not
work for chars, e.g.\ \f[C]#\[rs]a\f[R], which will be presented in the
return value as its integer value, i.e.\ \f[C]\[dq]97\[dq]\f[R].
.IP
.nf
\f[C]
> (clj:str #\[rs]a \[dq]bc\[dq])
\[dq]97bc\[dq]
> (clj:str \[dq]a\[dq] \[dq]bc\[dq])
\[dq]abc\[dq]
\f[R]
.fi
.PP
\f[B](lazy-seq)\f[R]
.PP
\f[B](lazy-seq seq)\f[R]
.PP
Return a (possibly infinite) lazy sequence from a given lazy sequence
\f[C]seq\f[R] or a finite lazy sequence from given list \f[C]seq\f[R].
A lazy sequence is treated as finite if at any iteration it produces the
empty list, instead of a cons cell with data as the head and a nullary
function for the next iteration as the tail.
.PP
\f[B](conj coll . xs)\f[R]
.PP
conj[oin] a value onto an existing collection.
Prepend to a list, append to a tuple, and merge maps.
.SS Clojure-inspired \f[I]if\f[R] Macro
.PP
\f[B](if test then)\f[R]
.PP
\f[B](if test then else)\f[R]
.PP
If \f[C]test\f[R] evaluates to anything other than \f[C]\[aq]false\f[R]
or \f[C]\[aq]undefined\f[R], return \f[C]then\f[R], otherwise
\f[C]else\f[R], if given, else \f[C]\[aq]undefined\f[R].
.SS Function Composition
.PP
\f[B](comp f g)\f[R]
.PP
Right to left function composition.
.PP
\f[B](comp fs x)\f[R]
.PP
Compose a list of functions \f[C]fs\f[R], right to left, and apply the
resulting function to \f[C]x\f[R].
.PP
\f[B](comp f g x)\f[R]
.PP
Equivalent to \f[C](funcall (comp f g) x)\f[R].
.PP
\f[B](comp fs)\f[R]
.PP
Compose a list of functions \f[C]fs\f[R] from right to left.
.PP
\f[B](comp)\f[R]
.PP
Equivalent to \f[C]#\[aq]identity/1\f[R].
.SS Usage
.PP
The following examples assume \f[C]#\[aq]1+/1\f[R] is defined:
.IP
.nf
\f[C]
> (defun 1+ (x) (+ x 1))
1+
\f[R]
.fi
.IP
.nf
\f[C]
> (funcall (clj:comp #\[aq]math:sin/1 #\[aq]math:asin/1) 0.5)
0.49999999999999994
> (funcall (clj:comp (list #\[aq]1+/1 #\[aq]math:sin/1 #\[aq]math:asin/1) 0.5))
1.5
\f[R]
.fi
.PP
Or used in another function call:
.IP
.nf
\f[C]
> (lists:filter (clj:comp #\[aq]not/1 #\[aq]zero?/1)
    \[aq](0 1 0 2 0 3 0 4))
(1 2 3 4)
\f[R]
.fi
.PP
The usage above is best when \f[B]comp\f[R] will be called by
higher-order functions like \f[B]lists:foldl/3\f[R] or
\f[B]lists:filter/2\f[R], etc.
However, one may also call \f[B]comp\f[R] in the following manner, best
suited for direct usage:
.IP
.nf
\f[C]
> (clj:comp #\[aq]math:sin/1 #\[aq]math:asin/1 0.5)
0.49999999999999994
> (clj:comp (list #\[aq]1+/1 #\[aq]math:sin/1 #\[aq]math:asin/1) 0.5)
1.5
\f[R]
.fi
.SS Partial Application
.PP
\f[B](partial f args)\f[R]
.PP
\f[B](partial f arg-1)\f[R]
.PP
Partially apply \f[C]f\f[R] to a given argument \f[C]arg-1\f[R] or list
of \f[C]args\f[R].
.SS Usage
.IP
.nf
\f[C]
> (set f (clj:partial #\[aq]+/2 1))
#Fun<clj.3.121115395>
> (funcall f 2)
3
> (set f (clj:partial #\[aq]+/3 1))
#Fun<clj.3.121115395>
> (funcall f \[aq](2 3))
6
> (set f (clj:partial #\[aq]+/3 \[aq](2 3)))
#Fun<clj.3.121115395>
> (funcall f 4)
9
> (set f (clj:partial #\[aq]+/4 \[aq](2 3)))
#Fun<clj.3.121115395>
> (funcall f \[aq](4 5))
14
\f[R]
.fi
.PP
Note that to partially apply a function that expects a list, you must
wrap said list into a (singleton) list.
.IP
.nf
\f[C]
> (set double (clj:partial #\[aq]*/2 2))
#Fun<clj.5.16146786>
> (set f (clj:partial #\[aq]lists:map/2 double))
#Fun<clj.5.16146786>
> (funcall f \[aq]((1 2 3)))
(2 4 6)
\f[R]
.fi
.SS Predicate Functions
.PP
N.B.
These functions may \f[I]not\f[R] be used in guards.
.PP
\f[B](string? data)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]data\f[R] is a flat list of printable
characters.
.PP
\f[B](unicode? data)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]data\f[R] is a flat list of printable
Unicode characters.
.PP
\f[B](list? data)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]data\f[R] is a list and not a string.
.PP
\f[B](set? data)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]data\f[R] is appears to be a
(possibly ordered) set.
.PP
\f[B](dict? data)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]data\f[R] is a dictionary.
.PP
\f[B](proplist? lst)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]lst\f[R] is a list where
\f[B]proplist-kv?/1\f[R] returns \f[C]\[aq]true\f[R] for all elements in
\f[C]lst\f[R].
.PP
\f[B](proplist-kv? data)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if a \f[C]data\f[R] is a key/value tuple or
an atom.
.PP
\f[B](queue? x)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is a queue.
.PP
\f[B](empty? x)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]x\f[R] is the empty list, tuple, map,
dictionary, queue, or general balanced tree.
.PP
\f[B](every? pred lst)\f[R]
.PP
\f[B](all? pred lst)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C](pred x)\f[R] returns
\f[C]\[aq]true\f[R] for every \f[C]x\f[R] in \f[C]lst\f[R].
.PP
\f[B](any? pred lst)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C](pred x)\f[R] returns
\f[C]\[aq]true\f[R] for any \f[C]x\f[R] in \f[C]lst\f[R].
.PP
\f[B](not-any? pred lst)\f[R]
.PP
Return \f[C]\[aq]false\f[R] if \f[C](pred x)\f[R] returns
\f[C]\[aq]true\f[R] for any \f[C]x\f[R] in \f[C]lst\f[R].
.PP
\f[B](element? elem data)\f[R]
.PP
Return \f[C]\[aq]true\f[R] if \f[C]elem\f[R] is an element of
\f[C]data\f[R], where \f[C]data\f[R] is a list, set or ordset.
.SS Sequence Functions
.PP
\f[B](seq end)\f[R]
.PP
Equivalent to \f[C](seq 1 end)\f[R].
.PP
\f[B](seq start end)\f[R]
.PP
Equivalent to \f[C](seq start end 1)\f[R].
.PP
\f[B](seq start end step)\f[R]
.PP
Return a sequence of integers, starting with \f[C]start\f[R], containing
the successive results of adding \f[C]step\f[R] to the previous element,
until \f[C]end\f[R] has been reached or password.
In the latter case, \f[C]end\f[R] is not an element of the sequence.
.PP
\f[B](next func)\f[R]
.PP
Equivalent to \f[C](next func 1 1)\f[R].
.PP
\f[B](next func start)\f[R]
.PP
Equivalent to \f[C](next func start 1)\f[R].
.PP
\f[B](next func start step)\f[R]
.PP
Return a nullary function that returns a cons cell with \f[C]start\f[R]
as the head and a nullary function,
\f[C](next func (funcall func start step) step)\f[R] as the tail.
The result can be treated as a (possibly infinite) lazy list, which only
computes subsequent values as needed.
.PP
\f[B](lazy-seq seq)\f[R]
.PP
Return a lazy sequence (possibly infinite) from given lazy sequence
\f[C]seq\f[R] or finite lazy sequence from given list \f[C]seq\f[R].
Lazy sequence is treated as finite if at any iteration it produces empty
list instead of data as its head and nullary function for next iteration
as its tail.
.PP
\f[B](cycle lst)\f[R]
.PP
Return a lazy infinite sequence with all elements from a given list
\f[C]lst\f[R] or another lazy sequence cycled.
.PP
See \f[B]next/3\f[R] for details on the structure.
.PP
\f[B](range)\f[R]
.PP
Equivalent to \f[C](range 1 1)\f[R].
.PP
\f[B](range start)\f[R]
.PP
Equivalent to \f[C](range start 1)\f[R].
.PP
\f[B](range start step)\f[R]
.PP
Return a lazy list of integers, starting with \f[C]start\f[R] and
increasing by \f[C]step\f[R].
Equivalent to \f[C](next #\[aq]+/2 start step)\f[R].
See also: \f[B]next/3\f[R].
.PP
\f[B](drop n lst)\f[R]
.PP
\f[B](drop \[cq]all lst)\f[R]
.PP
Return a list of all but the first \f[C]n\f[R] elements in
\f[C]lst\f[R].
If \f[C]n\f[R] is the atom \f[C]all\f[R], return the empty list.
.PP
\f[B](take n lst)\f[R]
.PP
\f[B](take \[cq]all lst)\f[R]
.PP
Given a (possibly lazy) list \f[C]lst\f[R], return a list of the first
\f[C]n\f[R] elements of \f[C]lst\f[R], or all elements if there are
fewer than \f[C]n\f[R].
If \f[C]n\f[R] is the atom \f[C]all\f[R] and \f[C]lst\f[R] is a
\[lq]normal\[rq] list, return \f[C]lst\f[R].
.PP
\f[B](split-at n lst)\f[R]
.PP
Return a tuple of \f[C]\[ga]#(,(take n lst) ,(drop n lst))\f[R].
.PP
\f[B](partition n lst)\f[R]
.PP
Equivalent to \f[C](partition n n lst)\f[R].
.PP
\f[B](partition n step lst)\f[R]
.PP
Equivalent to \f[C](partition n step () lst)\f[R].
.PP
\f[B](partition n step pad lst)\f[R]
.PP
Return a list of lists of \f[C]n\f[R] items each, at offsets
\f[C]step\f[R] apart.
Use the elements of \f[C]pad\f[R] as necessary to complete the last
partition up to \f[C]n\f[R] elements.
In case there are not enough padding elements, return a partition with
less than \f[C]n\f[R] items.
.PP
\f[B](partition-all n lst)\f[R]
.PP
Equivalent to \f[C](partition-all n n lst)\f[R].
.PP
\f[B](partition-all n step lst)\f[R]
.PP
Return a list of lists like \f[B]partition/3\f[R], possibly including
partitions with fewer than \f[C]n\f[R] elements at the end.
.PP
\f[B](interleave list-1 list-2)\f[R]
.PP
Return a list of the first element of each list, then the second, etc.
.PP
\f[B](get-in data keys)\f[R]
.PP
Equivalent to \f[C](get-in data keys \[aq]undefined)\f[R].
.PP
\f[B](get-in data keys not-found)\f[R]
.PP
Return the value in a nested associative structure, where \f[C]keys\f[R]
is a list of keys or list indices.
Return the atom \f[C]not-found\f[R] if the key is not present or index
is out of bounds, or the \f[C]not-found\f[R] value.
.PP
\f[B](reduce func (cons head tail))\f[R]
.PP
Equivalent to \f[C](reduce func head tail)\f[R].
.PP
\f[B](reduce func acc lst)\f[R]
.PP
Equivalent to \f[C](lists:foldl func acc lst)\f[R].
.PP
\f[B](repeat x)\f[R]
.PP
Return a lazy infinite sequence of \f[C]x\f[R]s.
.PP
See \f[B]next/3\f[R] for details on the structure.
.PP
\f[B](repeat n f)\f[R]
.PP
Given a nullary function \f[C]f\f[R], return a list of \f[C]n\f[R]
applications of \f[C]f\f[R].
.PP
\f[B](repeat n x)\f[R]
.PP
Given a term \f[C]x\f[R], return a list of \f[C]n\f[R] copies of
\f[C]x\f[R].
.SS Other Functions
.PP
\f[B](identity x)\f[R]
.PP
Identity function.
.PP
\f[B](constantly x)\f[R]
.PP
Return a unary function that returns \f[C]x\f[R].
N.B.
This is like Haskell\[cq]s \f[C]const\f[R] rather than Clojure\[cq]s
\f[C]constantly\f[R].
.PP
\f[B](inc x)\f[R]
.PP
Increment \f[C]x\f[R] by 1.
.PP
\f[B](dec x)\f[R]
.PP
Decrement \f[C]x\f[R] by 1.
.SH AUTHORS
Tim Dysinger, Duncan McGreggor, Eric Bailey.
